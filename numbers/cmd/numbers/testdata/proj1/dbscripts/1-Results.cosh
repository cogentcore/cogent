debug off

// for some reason the above debug off statement is necessary to make this all compile.

// Result has info for one loaded result, in form of an etable.Table
type Result struct {

	// job id for results
	JobID string

	// description of job
	Message string

	// path to data
	Path string

	// result data
	Table *table.Table
}

var Results []*Result

var ResultsVals = map[string]string{"0-File Contains": "", "1-Ext": ".tsv"}

func OpenResultFiles(jobs []string, contains, ext string) {
	Results = []*Result{}
	for i, jid := range jobs {
		jpath := filepath.Join(br.DataRoot, DataDir, jid)
		fls := dirs.ExtFilenames(jpath, ext)
		ifls := []string{}
		for _, fn := range fls {
			if !strings.Contains(fn, contains) {
				continue
			}
			dt := table.NewTable()
			fpath := filepath.Join(jpath, fn)
			dt.OpenCSV(core.Filename(fpath), table.Tab)
			Results = append(Results, &Result{JobID: jid, Path: fpath, Table: dt})
		}
	}
	if len(Results) == 0 {
		core.MessageSnackbar(br, "No files containing: " + contains + " with extension: " + ext)
		return
	}
	br.NewTabTableView("Results", &Results)
	br.Update()
}

func OpenResults() {
	tv := JobsTableView
	jobs := tv.SelectedColumnStrings("JobID")
	if len(jobs) == 0 {
		fmt.Println("No rows selected")
		return
	}
	databrowser.Prompt(br, ResultsVals, "Open results data for files", func() {
		OpenResultFiles(jobs, ResultsVals["0-File Contains"], ResultsVals["1-Ext"])
	})
}

OpenResults()

