debug on

// for some reason the above debug off statement is necessary to make this all compile.

// Result has info for one loaded result, in form of an etable.Table
type Result struct {

	// job id for results
	JobID string

	// description of job
	Message string

	// path to data
	Path string

	// result data
	Table *table.Table
}

var Results []*Result

// FilterResults specifies which results files to open
type FilterResults struct {
	// File name contains this string
	FileContains string `width:"60"`

	//	extension of files, e.g., .tsv
	Ext string
}

Filter := FilterResults{Ext: ".tsv"}

func OpenResultFiles(jobs []string, filter FilterResults) {
	for i, jid := range jobs {
		jpath := filepath.Join(br.DataRoot, DataDir, jid)
		fls := dirs.ExtFilenames(jpath, filter.Ext)
		ifls := []string{}
		for _, fn := range fls {
			if filter.FileContains != "" && !strings.Contains(fn, filter.FileContains) {
				continue
			}
			dt := table.NewTable()
			fpath := filepath.Join(jpath, fn)
			dt.OpenCSV(core.Filename(fpath), table.Tab)
			Results = append(Results, &Result{JobID: jid, Path: fpath, Table: dt})
		}
	}
	if len(Results) == 0 {
		core.MessageSnackbar(br, "No files containing: " + filter.FileContains + " with extension: " + filter.Ext)
		return
	}
	br.NewTabTableView("Results", &Results)
	br.Update()
}

func OpenResults() {
	tv := JobsTableView
	jobs := tv.SelectedColumnStrings("JobID")
	if len(jobs) == 0 {
		fmt.Println("No rows selected")
		return
	}
	databrowser.Prompt(br, &Filter, "Open results data for files", func() {
		OpenResultFiles(jobs, Filter)
	})
}

OpenResults()

