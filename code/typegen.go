// Code generated by "core generate"; DO NOT EDIT.

package code

import (
	"regexp"
	"time"

	"cogentcore.org/core/base/fileinfo"
	"cogentcore.org/core/core"
	"cogentcore.org/core/parse/lexer"
	"cogentcore.org/core/parse/syms"
	"cogentcore.org/core/tree"
	"cogentcore.org/core/types"
)

// CodeViewType is the [types.Type] for [CodeView]
var CodeViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.CodeView", IDName: "code-view", Doc: "CodeView is the core editor and tab viewer framework for the Code system.  The\ndefault view has a tree browser of files on the left, editor panels in the\nmiddle, and a tabbed viewer on the right.", Methods: []types.Method{{Name: "MakeToolbar", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"p"}}, {Name: "UpdateFiles", Doc: "UpdateFiles updates the list of files saved in project", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "OpenRecent", Doc: "OpenRecent opens a recently used file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}}, {Name: "OpenFile", Doc: "OpenFile opens file in an open project if it has the same path as the file\nor in a new window.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fnm"}}, {Name: "OpenPath", Doc: "OpenPath creates a new project by opening given path, which can either be a\nspecific file or a folder containing multiple files of interest -- opens in\ncurrent CodeView object if it is empty, or otherwise opens a new window.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"path"}, Returns: []string{"CodeView"}}, {Name: "OpenProject", Doc: "OpenProject opens .code project file and its settings from given filename, in a standard\ntoml-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"CodeView"}}, {Name: "NewProject", Doc: "NewProject creates a new project at given path, making a new folder in that\npath -- all CodeView projects are essentially defined by a path to a folder\ncontaining files.  If the folder already exists, then use OpenPath.\nCan also specify main language and version control type", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"path", "folder", "mainLang", "VersionControl"}, Returns: []string{"CodeView"}}, {Name: "NewFile", Doc: "NewFile creates a new file in the project", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename", "addToVcs"}}, {Name: "SaveProject", Doc: "SaveProject saves project file containing custom project settings, in a\nstandard toml-formatted file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SaveProjectAs", Doc: "SaveProjectAs saves project custom settings to given filename, in a standard\ntoml-formatted file\nsaveAllFiles indicates if user should be prompted for saving all files\nreturns true if the user was prompted, false otherwise", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"bool"}}, {Name: "ExecCmdNameActive", Doc: "ExecCmdNameActive calls given command on current active texteditor", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"cmdNm"}}, {Name: "ExecCmd", Doc: "ExecCmd pops up a menu to select a command appropriate for the current\nactive text view, and shows output in Tab with name of command", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "RunBuild", Doc: "RunBuild runs the BuildCmds set for this project", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Run", Doc: "Run runs the RunCmds set for this project", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Commit", Doc: "Commit commits the current changes using relevant VCS tool.\nChecks for VCS setting and for unsaved files.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CursorToHistPrev", Doc: "CursorToHistPrev moves back to the previous history item.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"bool"}}, {Name: "CursorToHistNext", Doc: "CursorToHistNext moves forward to the next history item.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"bool"}}, {Name: "ReplaceInActive", Doc: "ReplaceInActive does query-replace in active file only", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CutRect", Doc: "CutRect cuts rectangle in active text view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CopyRect", Doc: "CopyRect copies rectangle in active text view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "PasteRect", Doc: "PasteRect cuts rectangle in active text view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "RegisterCopy", Doc: "RegisterCopy saves current selection in active text view\nto register of given name returns true if saved.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"regNm"}}, {Name: "RegisterPaste", Doc: "RegisterPaste prompts user for available registers,\nand pastes selected one into active text view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"ctx"}}, {Name: "CommentOut", Doc: "CommentOut comments-out selected lines in active text view\nand uncomments if already commented\nIf multiple lines are selected and any line is uncommented all will be commented", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"bool"}}, {Name: "Indent", Doc: "Indent indents selected lines in active view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"bool"}}, {Name: "ReCase", Doc: "ReCase replaces currently selected text in current active view with given case", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"c"}, Returns: []string{"string"}}, {Name: "JoinParaLines", Doc: "JoinParaLines merges sequences of lines with hard returns forming paragraphs,\nseparated by blank lines, into a single line per paragraph,\nfor given selected region (full text if no selection)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "TabsToSpaces", Doc: "TabsToSpaces converts tabs to spaces\nfor given selected region (full text if no selection)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SpacesToTabs", Doc: "SpacesToTabs converts spaces to tabs\nfor given selected region (full text if no selection)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DiffFiles", Doc: "DiffFiles shows the differences between two given files\nin side-by-side DiffView and in the console as a context diff.\nIt opens the files as file nodes and uses existing contents if open already.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fnmA", "fnmB"}}, {Name: "DiffFileNode", Doc: "DiffFileNode shows the differences between given file node as the A file,\nand another given file as the B file,\nin side-by-side DiffView and in the console as a context diff.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fna", "fnmB"}}, {Name: "CountWords", Doc: "CountWords counts number of words (and lines) in active file\nreturns a string report thereof.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"string"}}, {Name: "CountWordsRegion", Doc: "CountWordsRegion counts number of words (and lines) in selected region in file\nif no selection, returns numbers for entire file.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"string"}}, {Name: "SaveActiveView", Doc: "SaveActiveView saves the contents of the currently active texteditor", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SaveActiveViewAs", Doc: "SaveActiveViewAs save with specified filename the contents of the\ncurrently active texteditor", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}}, {Name: "RevertActiveView", Doc: "RevertActiveView revert active view to saved version", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "CloseActiveView", Doc: "CloseActiveView closes the buffer associated with active view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "NextViewFile", Doc: "NextViewFile sets the next text view to view given file name -- include as\nmuch of name as possible to disambiguate -- will use the first matching --\nif already being viewed, that is activated -- returns texteditor and its\nindex, false if not found", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fnm"}, Returns: []string{"TextEditor", "int", "bool"}}, {Name: "ViewFile", Doc: "ViewFile views file in an existing TextEditor if it is already viewing that\nfile, otherwise opens ViewFileNode in active buffer", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"fnm"}, Returns: []string{"TextEditor", "int", "bool"}}, {Name: "CloneActiveView", Doc: "CloneActiveView sets the next text view to view the same file currently being vieweds\nin the active view. returns text view and index", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"TextEditor", "int"}}, {Name: "SaveAll", Doc: "SaveAll saves all of the open filenodes to their current file names\nand saves the project state if it has been saved before (i.e., the .code file exists)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "FocusNextPanel", Doc: "FocusNextPanel moves the keyboard focus to the next panel to the right", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "FocusPrevPanel", Doc: "FocusPrevPanel moves the keyboard focus to the previous panel to the left", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditProjectSettings", Doc: "EditProjectSettings allows editing of project settings (settings specific to this project)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SplitsSetView", Doc: "SplitsSetView sets split view splitters to given named setting", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"split"}}, {Name: "SplitsSave", Doc: "SplitsSave saves current splitter settings to named splitter settings under\nexisting name, and saves to prefs file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"split"}}, {Name: "SplitsSaveAs", Doc: "SplitsSaveAs saves current splitter settings to new named splitter settings, and\nsaves to prefs file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"name", "desc"}}, {Name: "SplitsEdit", Doc: "SplitsEdit opens the SplitsView editor to customize saved splitter settings", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Find", Doc: "Find does Find / Replace in files, using given options and filters -- opens up a\nmain tab with the results and further controls.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"find", "repl", "ignoreCase", "regExp", "loc", "langs"}}, {Name: "Spell", Doc: "Spell checks spelling in active text view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Symbols", Doc: "Symbols displays the Symbols of a file or package", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "Debug", Doc: "Debug starts the debugger on the RunExec executable.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DebugTest", Doc: "DebugTest runs the debugger using testing mode in current active texteditor path", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "DebugAttach", Doc: "DebugAttach runs the debugger by attaching to an already-running process.\npid is the process id to attach to.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"pid"}}, {Name: "VCSUpdateAll", Doc: "VCSUpdateAll does an Update (e.g., Pull) on all VCS repositories within\nthe open tree nodes in FileTree.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "VCSLog", Doc: "VCSLog shows the VCS log of commits in this project,\nin an interactive browser from which any revisions can be\ncompared and diffs browsed.\nIf since is non-empty, it should be a date-like expression\nthat the VCS will understand, such as 1/1/2020, yesterday,\nlast year, etc.  SVN only understands a number as a maximum\nnumber of items to return.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"since"}, Returns: []string{"Log", "error"}}, {Name: "OpenConsoleTab", Doc: "OpenConsoleTab opens a main tab displaying console output (stdout, stderr)", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "ChooseRunExec", Doc: "ChooseRunExec selects the executable to run for the project", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"exePath"}}, {Name: "HelpWiki", Doc: "HelpWiki opens wiki page for code on github", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "ProjectRoot", Doc: "root directory for the project -- all projects must be organized within a top-level root directory, with all the files therein constituting the scope of the project -- by default it is the path for ProjectFilename"}, {Name: "ProjectFilename", Doc: "current project filename for saving / loading specific Code configuration information in a .code file (optional)"}, {Name: "ActiveFilename", Doc: "filename of the currently active texteditor"}, {Name: "ActiveLang", Doc: "language for current active filename"}, {Name: "ActiveVCS", Doc: "VCS repo for current active filename"}, {Name: "ActiveVCSInfo", Doc: "VCS info for current active filename (typically branch or revision) -- for status"}, {Name: "Changed", Doc: "has the root changed?  we receive update signals from root for changes"}, {Name: "StatusMessage", Doc: "the last status update message"}, {Name: "LastSaveTStamp", Doc: "timestamp for when a file was last saved -- provides dirty state for various updates including rebuilding in debugger"}, {Name: "Files", Doc: "all the files in the project directory and subdirectories"}, {Name: "ActiveTextEditorIndex", Doc: "index of the currently active texteditor -- new files will be viewed in other views if available"}, {Name: "OpenNodes", Doc: "list of open nodes, most recent first"}, {Name: "CmdBufs", Doc: "the command buffers for commands run in this project"}, {Name: "CmdHistory", Doc: "history of commands executed in this session"}, {Name: "RunningCmds", Doc: "currently running commands in this project"}, {Name: "ArgVals", Doc: "current arg var vals"}, {Name: "Settings", Doc: "settings for this project -- this is what is saved in a .code project file"}, {Name: "CurDbg", Doc: "current debug view"}, {Name: "KeySeq1", Doc: "first key in sequence if needs2 key pressed"}, {Name: "UpdateMu", Doc: "mutex for protecting overall updates to CodeView"}}, Instance: &CodeView{}})

// NewCodeView returns a new [CodeView] with the given optional parent:
// CodeView is the core editor and tab viewer framework for the Code system.  The
// default view has a tree browser of files on the left, editor panels in the
// middle, and a tabbed viewer on the right.
func NewCodeView(parent ...tree.Node) *CodeView { return tree.New[*CodeView](parent...) }

// NodeType returns the [*types.Type] of [CodeView]
func (t *CodeView) NodeType() *types.Type { return CodeViewType }

// New returns a new [*CodeView] value
func (t *CodeView) New() tree.Node { return &CodeView{} }

// SetProjectRoot sets the [CodeView.ProjectRoot]:
// root directory for the project -- all projects must be organized within a top-level root directory, with all the files therein constituting the scope of the project -- by default it is the path for ProjectFilename
func (t *CodeView) SetProjectRoot(v core.Filename) *CodeView { t.ProjectRoot = v; return t }

// SetProjectFilename sets the [CodeView.ProjectFilename]:
// current project filename for saving / loading specific Code configuration information in a .code file (optional)
func (t *CodeView) SetProjectFilename(v core.Filename) *CodeView { t.ProjectFilename = v; return t }

// SetActiveLang sets the [CodeView.ActiveLang]:
// language for current active filename
func (t *CodeView) SetActiveLang(v fileinfo.Known) *CodeView { t.ActiveLang = v; return t }

// SetStatusMessage sets the [CodeView.StatusMessage]:
// the last status update message
func (t *CodeView) SetStatusMessage(v string) *CodeView { t.StatusMessage = v; return t }

// SetOpenNodes sets the [CodeView.OpenNodes]:
// list of open nodes, most recent first
func (t *CodeView) SetOpenNodes(v OpenNodes) *CodeView { t.OpenNodes = v; return t }

// DebugViewType is the [types.Type] for [DebugView]
var DebugViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.DebugView", IDName: "debug-view", Doc: "DebugView is the debugger", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Sup", Doc: "supported file type to determine debugger"}, {Name: "ExePath", Doc: "path to executable / dir to debug"}, {Name: "DbgTime", Doc: "time when dbg was last restarted"}, {Name: "Dbg", Doc: "the debugger"}, {Name: "State", Doc: "all relevant debug state info"}, {Name: "CurFileLoc", Doc: "current ShowFile location -- cleared before next one or run"}, {Name: "BBreaks", Doc: "backup breakpoints list -- to track deletes"}, {Name: "OutputBuffer", Doc: "output from the debugger"}, {Name: "Code", Doc: "parent code project"}}, Instance: &DebugView{}})

// NewDebugView returns a new [DebugView] with the given optional parent:
// DebugView is the debugger
func NewDebugView(parent ...tree.Node) *DebugView { return tree.New[*DebugView](parent...) }

// NodeType returns the [*types.Type] of [DebugView]
func (t *DebugView) NodeType() *types.Type { return DebugViewType }

// New returns a new [*DebugView] value
func (t *DebugView) New() tree.Node { return &DebugView{} }

// SetSup sets the [DebugView.Sup]:
// supported file type to determine debugger
func (t *DebugView) SetSup(v fileinfo.Known) *DebugView { t.Sup = v; return t }

// SetExePath sets the [DebugView.ExePath]:
// path to executable / dir to debug
func (t *DebugView) SetExePath(v string) *DebugView { t.ExePath = v; return t }

// SetDbgTime sets the [DebugView.DbgTime]:
// time when dbg was last restarted
func (t *DebugView) SetDbgTime(v time.Time) *DebugView { t.DbgTime = v; return t }

// VarViewType is the [types.Type] for [VarView]
var VarViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.VarView", IDName: "var-view", Doc: "VarView shows a debug variable in an inspector-like framework,\nwith sub-variables in a tree.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Var", Doc: "variable being edited"}, {Name: "SelectVar"}, {Name: "FrameInfo", Doc: "frame info"}, {Name: "DbgView", Doc: "parent DebugView"}}, Instance: &VarView{}})

// NewVarView returns a new [VarView] with the given optional parent:
// VarView shows a debug variable in an inspector-like framework,
// with sub-variables in a tree.
func NewVarView(parent ...tree.Node) *VarView { return tree.New[*VarView](parent...) }

// NodeType returns the [*types.Type] of [VarView]
func (t *VarView) NodeType() *types.Type { return VarViewType }

// New returns a new [*VarView] value
func (t *VarView) New() tree.Node { return &VarView{} }

// SetDbgView sets the [VarView.DbgView]:
// parent DebugView
func (t *VarView) SetDbgView(v *DebugView) *VarView { t.DbgView = v; return t }

// FileNodeType is the [types.Type] for [FileNode]
var FileNodeType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.FileNode", IDName: "file-node", Doc: "FileNode is Code version of FileNode for FileTree", Methods: []types.Method{{Name: "ExecCmdFile", Doc: "ExecCmdFile pops up a menu to select a command appropriate for the given node,\nand shows output in MainTab with name of command", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditFiles", Doc: "EditFiles calls EditFile on selected files", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "SetRunExecs", Doc: "SetRunExecs sets executable as the RunExec executable that will be run with Run / Debug buttons", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "Node"}}, Instance: &FileNode{}})

// NewFileNode returns a new [FileNode] with the given optional parent:
// FileNode is Code version of FileNode for FileTree
func NewFileNode(parent ...tree.Node) *FileNode { return tree.New[*FileNode](parent...) }

// NodeType returns the [*types.Type] of [FileNode]
func (t *FileNode) NodeType() *types.Type { return FileNodeType }

// New returns a new [*FileNode] value
func (t *FileNode) New() tree.Node { return &FileNode{} }

// FindViewType is the [types.Type] for [FindView]
var FindViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.FindView", IDName: "find-view", Doc: "FindView is a find / replace widget that displays results in a TextEditor\nand has a toolbar for controlling find / replace process.", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Code", Doc: "parent code project"}, {Name: "Time", Doc: "time of last find"}, {Name: "Re", Doc: "compiled regexp"}}, Instance: &FindView{}})

// NewFindView returns a new [FindView] with the given optional parent:
// FindView is a find / replace widget that displays results in a TextEditor
// and has a toolbar for controlling find / replace process.
func NewFindView(parent ...tree.Node) *FindView { return tree.New[*FindView](parent...) }

// NodeType returns the [*types.Type] of [FindView]
func (t *FindView) NodeType() *types.Type { return FindViewType }

// New returns a new [*FindView] value
func (t *FindView) New() tree.Node { return &FindView{} }

// SetCode sets the [FindView.Code]:
// parent code project
func (t *FindView) SetCode(v *CodeView) *FindView { t.Code = v; return t }

// SetTime sets the [FindView.Time]:
// time of last find
func (t *FindView) SetTime(v time.Time) *FindView { t.Time = v; return t }

// SetRe sets the [FindView.Re]:
// compiled regexp
func (t *FindView) SetRe(v *regexp.Regexp) *FindView { t.Re = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.SettingsData", IDName: "settings-data", Doc: "SettingsData is the data type for the overall user settings for Code.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Apply", Doc: "Apply settings updates things according with settings", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditLangOpts", Doc: "EditLangOpts opens the LangsView editor to customize options for each type of\nlanguage / data / file type.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditCmds", Doc: "EditCmds opens the CmdsView editor to customize commands you can run.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditSplits", Doc: "EditSplits opens the SplitsView editor to customize saved splitter settings", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "EditRegisters", Doc: "EditRegisters opens the RegistersView editor to customize saved registers", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Embeds: []types.Field{{Name: "SettingsBase"}}, Fields: []types.Field{{Name: "Files", Doc: "file picker settings"}, {Name: "EnvVars", Doc: "environment variables to set for this app -- if run from the command line, standard shell environment variables are inherited, but on some OS's (Mac), they are not set when run as a gui app"}, {Name: "SaveLangOpts", Doc: "if set, the current customized set of language options (see Edit Lang Opts) is saved / loaded along with other settings -- if not set, then you always are using the default compiled-in standard set (which will be updated)"}, {Name: "SaveCmds", Doc: "if set, the current customized set of command parameters (see Edit Cmds) is saved / loaded along with other settings -- if not set, then you always are using the default compiled-in standard set (which will be updated)"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.FileSettings", IDName: "file-settings", Doc: "FileSettings contains file picker settings", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Fields: []types.Field{{Name: "DirsOnTop", Doc: "if true, then all directories are placed at the top of the tree -- otherwise everything is alpha sorted"}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.ProjectSettings", IDName: "project-settings", Doc: "ProjectSettings are the settings for saving for a project. This IS the project file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Open", Doc: "Open open from file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Save", Doc: "Save save to file", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"filename"}, Returns: []string{"error"}}}, Fields: []types.Field{{Name: "Files", Doc: "file picker settings"}, {Name: "Editor", Doc: "editor settings"}, {Name: "SplitName", Doc: "current named-split config in use for configuring the splitters"}, {Name: "MainLang", Doc: "the language associated with the most frequently encountered file\nextension in the file tree -- can be manually set here as well"}, {Name: "VersionControl", Doc: "the type of version control system used in this project (git, svn, etc).\nfilters commands available"}, {Name: "ProjectFilename", Doc: "current project filename for saving / loading specific Code\nconfiguration information in a .code file (optional)"}, {Name: "ProjectRoot", Doc: "root directory for the project. all projects must be organized within\na top-level root directory, with all the files therein constituting\nthe scope of the project. By default it is the path for ProjectFilename"}, {Name: "GoMod", Doc: "if true, use Go modules, otherwise use GOPATH -- this sets your effective GO111MODULE environment variable accordingly, dynamically -- updated by toolbar checkbox, dynamically"}, {Name: "BuildCmds", Doc: "command(s) to run for main Build button"}, {Name: "BuildDir", Doc: "build directory for main Build button -- set this to the directory where you want to build the main target for this project -- avail as {BuildDir} in commands"}, {Name: "BuildTarg", Doc: "build target for main Build button, if relevant for your  BuildCmds"}, {Name: "RunExec", Doc: "executable to run for this project via main Run button -- called by standard Run Project command"}, {Name: "RunCmds", Doc: "command(s) to run for main Run button (typically Run Project)"}, {Name: "Debug", Doc: "custom debugger parameters for this project"}, {Name: "Find", Doc: "saved find params"}, {Name: "Symbols", Doc: "saved structure params"}, {Name: "Dirs", Doc: "directory properties"}, {Name: "Register", Doc: "last register used"}, {Name: "Splits", Doc: "current splitter splits"}}})

// SpellViewType is the [types.Type] for [SpellView]
var SpellViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.SpellView", IDName: "spell-view", Doc: "SpellView is a widget that displays results of spell check", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Code", Doc: "parent code project"}, {Name: "Text", Doc: "texteditor that we're spell-checking"}, {Name: "Errs", Doc: "current spelling errors"}, {Name: "CurLn", Doc: "current line in text we're on"}, {Name: "CurIndex", Doc: "current index in Errs we're on"}, {Name: "UnkLex", Doc: "current unknown lex token"}, {Name: "UnkWord", Doc: "current unknown word"}, {Name: "Suggest", Doc: "a list of suggestions from spell checker"}, {Name: "LastAction", Doc: "last user action (ignore, change, learn)"}}, Instance: &SpellView{}})

// NewSpellView returns a new [SpellView] with the given optional parent:
// SpellView is a widget that displays results of spell check
func NewSpellView(parent ...tree.Node) *SpellView { return tree.New[*SpellView](parent...) }

// NodeType returns the [*types.Type] of [SpellView]
func (t *SpellView) NodeType() *types.Type { return SpellViewType }

// New returns a new [*SpellView] value
func (t *SpellView) New() tree.Node { return &SpellView{} }

// SetCode sets the [SpellView.Code]:
// parent code project
func (t *SpellView) SetCode(v *CodeView) *SpellView { t.Code = v; return t }

// SetText sets the [SpellView.Text]:
// texteditor that we're spell-checking
func (t *SpellView) SetText(v *TextEditor) *SpellView { t.Text = v; return t }

// SetErrs sets the [SpellView.Errs]:
// current spelling errors
func (t *SpellView) SetErrs(v lexer.Line) *SpellView { t.Errs = v; return t }

// SetCurLn sets the [SpellView.CurLn]:
// current line in text we're on
func (t *SpellView) SetCurLn(v int) *SpellView { t.CurLn = v; return t }

// SetCurIndex sets the [SpellView.CurIndex]:
// current index in Errs we're on
func (t *SpellView) SetCurIndex(v int) *SpellView { t.CurIndex = v; return t }

// SetUnkLex sets the [SpellView.UnkLex]:
// current unknown lex token
func (t *SpellView) SetUnkLex(v lexer.Lex) *SpellView { t.UnkLex = v; return t }

// SetUnkWord sets the [SpellView.UnkWord]:
// current unknown word
func (t *SpellView) SetUnkWord(v string) *SpellView { t.UnkWord = v; return t }

// SetSuggest sets the [SpellView.Suggest]:
// a list of suggestions from spell checker
func (t *SpellView) SetSuggest(v ...string) *SpellView { t.Suggest = v; return t }

// SetLastAction sets the [SpellView.LastAction]:
// last user action (ignore, change, learn)
func (t *SpellView) SetLastAction(v *core.Button) *SpellView { t.LastAction = v; return t }

// SymbolsViewType is the [types.Type] for [SymbolsView]
var SymbolsViewType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.SymbolsView", IDName: "symbols-view", Doc: "SymbolsView is a widget that displays results of a file or package parse", Embeds: []types.Field{{Name: "Frame"}}, Fields: []types.Field{{Name: "Code", Doc: "parent code project"}, {Name: "SymParams", Doc: "params for structure display"}, {Name: "Syms", Doc: "all the symbols for the file or package in a tree"}, {Name: "Match", Doc: "only show symbols that match this string"}}, Instance: &SymbolsView{}})

// NewSymbolsView returns a new [SymbolsView] with the given optional parent:
// SymbolsView is a widget that displays results of a file or package parse
func NewSymbolsView(parent ...tree.Node) *SymbolsView { return tree.New[*SymbolsView](parent...) }

// NodeType returns the [*types.Type] of [SymbolsView]
func (t *SymbolsView) NodeType() *types.Type { return SymbolsViewType }

// New returns a new [*SymbolsView] value
func (t *SymbolsView) New() tree.Node { return &SymbolsView{} }

// SetCode sets the [SymbolsView.Code]:
// parent code project
func (t *SymbolsView) SetCode(v *CodeView) *SymbolsView { t.Code = v; return t }

// SetSymParams sets the [SymbolsView.SymParams]:
// params for structure display
func (t *SymbolsView) SetSymParams(v SymbolsParams) *SymbolsView { t.SymParams = v; return t }

// SetSyms sets the [SymbolsView.Syms]:
// all the symbols for the file or package in a tree
func (t *SymbolsView) SetSyms(v *SymNode) *SymbolsView { t.Syms = v; return t }

// SetMatch sets the [SymbolsView.Match]:
// only show symbols that match this string
func (t *SymbolsView) SetMatch(v string) *SymbolsView { t.Match = v; return t }

// SymNodeType is the [types.Type] for [SymNode]
var SymNodeType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.SymNode", IDName: "sym-node", Doc: "SymNode represents a language symbol -- the name of the node is\nthe name of the symbol. Some symbols, e.g. type have children", Embeds: []types.Field{{Name: "NodeBase"}}, Fields: []types.Field{{Name: "Symbol", Doc: "the symbol"}}, Instance: &SymNode{}})

// NewSymNode returns a new [SymNode] with the given optional parent:
// SymNode represents a language symbol -- the name of the node is
// the name of the symbol. Some symbols, e.g. type have children
func NewSymNode(parent ...tree.Node) *SymNode { return tree.New[*SymNode](parent...) }

// NodeType returns the [*types.Type] of [SymNode]
func (t *SymNode) NodeType() *types.Type { return SymNodeType }

// New returns a new [*SymNode] value
func (t *SymNode) New() tree.Node { return &SymNode{} }

// SetSymbol sets the [SymNode.Symbol]:
// the symbol
func (t *SymNode) SetSymbol(v syms.Symbol) *SymNode { t.Symbol = v; return t }

// SymTreeType is the [types.Type] for [SymTree]
var SymTreeType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.SymTree", IDName: "sym-tree", Doc: "SymTree is a Tree that knows how to operate on FileNode nodes", Embeds: []types.Field{{Name: "Tree"}}, Instance: &SymTree{}})

// NewSymTree returns a new [SymTree] with the given optional parent:
// SymTree is a Tree that knows how to operate on FileNode nodes
func NewSymTree(parent ...tree.Node) *SymTree { return tree.New[*SymTree](parent...) }

// NodeType returns the [*types.Type] of [SymTree]
func (t *SymTree) NodeType() *types.Type { return SymTreeType }

// New returns a new [*SymTree] value
func (t *SymTree) New() tree.Node { return &SymTree{} }

// TextEditorType is the [types.Type] for [TextEditor]
var TextEditorType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.TextEditor", IDName: "text-editor", Doc: "TextEditor is the Code-specific version of the TextEditor, with support for\nsetting / clearing breakpoints, etc", Embeds: []types.Field{{Name: "Editor"}}, Fields: []types.Field{{Name: "Code"}}, Instance: &TextEditor{}})

// NewTextEditor returns a new [TextEditor] with the given optional parent:
// TextEditor is the Code-specific version of the TextEditor, with support for
// setting / clearing breakpoints, etc
func NewTextEditor(parent ...tree.Node) *TextEditor { return tree.New[*TextEditor](parent...) }

// NodeType returns the [*types.Type] of [TextEditor]
func (t *TextEditor) NodeType() *types.Type { return TextEditorType }

// New returns a new [*TextEditor] value
func (t *TextEditor) New() tree.Node { return &TextEditor{} }

// SetCode sets the [TextEditor.Code]
func (t *TextEditor) SetCode(v *CodeView) *TextEditor { t.Code = v; return t }

// CmdButtonType is the [types.Type] for [CmdButton]
var CmdButtonType = types.AddType(&types.Type{Name: "cogentcore.org/cogent/code.CmdButton", IDName: "cmd-button", Doc: "CmdButton represents a [CmdName] value with a button that opens a [CmdView].", Embeds: []types.Field{{Name: "Button"}}, Instance: &CmdButton{}})

// NewCmdButton returns a new [CmdButton] with the given optional parent:
// CmdButton represents a [CmdName] value with a button that opens a [CmdView].
func NewCmdButton(parent ...tree.Node) *CmdButton { return tree.New[*CmdButton](parent...) }

// NodeType returns the [*types.Type] of [CmdButton]
func (t *CmdButton) NodeType() *types.Type { return CmdButtonType }

// New returns a new [*CmdButton] value
func (t *CmdButton) New() tree.Node { return &CmdButton{} }
