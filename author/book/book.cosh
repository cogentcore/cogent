// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package book is the book-specific version of Cogent Author for
// rendering markdown source into various book documents,
// including .pdf via latex, .html, .docx and epub.
//
// These files should be located in the current directory where the command
// is run.  Author generates the output files based on Book.Name there,
// with all of the temporary files used in the generation process in the 
// 'author' directory.
package book

import (
	"fmt"
	
	"cogentcore.org/core/base/logx"
	coshell "cogentcore.org/core/shell"
)

var (
	shell = coshell.NewShell()
	pdInputs = filepath.Join("author", "pandoc-inputs")
)

// Book generates a book based on a set of markdown files, with the
// following required file names (with [] indicating optional files):
//
//	- metadata.yaml: pandoc metadata with various important options
//	- frontmatter.md: with copyright, dedication, foreward, preface, prologue sections.
//	- chapter-*.md: chapters, using 01 etc numbering to put in order.
//	- endmatter.md: includes epilogue, acknowledgements, author
//	- [appendix-*.md] appendicies, using a, b, c, etc labeling.
//	- [glossary.md] optional glossary that generates links in text.
//	- allrefs.bib: source of all references in BibTex format, to use in resolving citations.
func Book(c *author.Config) error { //types:add
	name := c.Output
	if name == "" {
		name = "book"
	}
	book := NewBookData(name)
	book.savePandocInputs()
	book.Refs() // note: we allow this to fail, in case using compiled refs
	mdfn := book.Markdown()
	if logx.UserLevel <= slog.LevelInfo {
		shell.Config.Echo = os.Stdout
	}
	var errs []error
	for _, fmt := range c.Formats {
		switch fmt {
		case author.HTML:
			err := book.HTML(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		case author.LaTeX:
			err := book.LaTeX(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		case author.PDF:
			err := book.PDF(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		case author.EPUB:
			err := book.EPUB(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		case author.DOCX:
			err := book.DOCX(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		}
	}
	return errors.Join(errs...)
}

// BookData has all of the info about the book.
type BookData struct {
	// Name is the overall name of the book.
	// Output files will be Name.pdf etc.
	Name string 
	
	// names of the chapters, in sorted order.
	Chapters []string
	
	// names of the appendicies.
	Appendicies []string
}

func NewBookData(name string) *BookData {
	return &BookData{Name: name}
}

func (bk *BookData) pandocMarkdownOpts() string {
	return "markdown+smart+line_blocks+escaped_line_breaks+fenced_code_blocks+fenced_code_attributes+backtick_code_blocks+yaml_metadata_block"
}

// HTML generates HTML file from given markdown filename
func (bk *BookData) HTML(mdfn string) error {
	fmt.Println("\n####################################\nGenerating HTML...\n")
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".html"
	pandoc -f {mdopts} --lua-filter {bk.pdi("glossary-filter.lua")} -F pandoc-crossref --citeproc --bibliography references.bib -t html --standalone --embed-resources --number-sections --css {bk.pdi("html.css")} -H {bk.pdi("head_include.html")} -o {trg} {mdfn}
	return nil
}

// PDF generates PDF file from given markdown filename
func (bk *BookData) PDF(mdfn string) error {
	fmt.Println("\n####################################\nGenerating PDF...\n")
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".pdf"
	// todo: -B {bk.pdi("cover-page.latex")} -- requires metadata replacement
	pandoc -f {mdopts} --lua-filter {bk.pdi("glossary-filter.lua")} -F pandoc-crossref --citeproc --bibliography references.bib -t latex --template {bk.pdi("latex.template")} -H {bk.pdi("header.latex")} --number-sections --toc -o {trg} {mdfn}
	return nil
}

// LaTeX generates LaTeX file from given markdown filename
func (bk *BookData) LaTeX(mdfn string) error {
	fmt.Println("\n####################################\nGenerating LaTeX...\n")
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".tex"
	// todo: -B {bk.pdi("cover-page.latex")} -- requires metadata replacement
	pandoc -f {mdopts} --lua-filter {bk.pdi("glossary-filter.lua")} -F pandoc-crossref --citeproc --bibliography references.bib -t latex --template {bk.pdi("latex.template")} -H {bk.pdi("header.latex")} --number-sections --toc -o {trg} {mdfn}
	return nil
}

// EPUB generates EPUB file from given markdown filename
func (bk *BookData) EPUB(mdfn string) error {
	fmt.Println("\n####################################\nGenerating ePUB...\n")
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".epub"
	pandoc -f {mdopts} --lua-filter {bk.pdi("glossary-filter.lua")} -F pandoc-crossref --citeproc --bibliography references.bib -t epub --standalone --embed-resources --number-sections --css {bk.pdi("epub.css")} -o {trg} {mdfn}
	return nil
}

// DOCX generates DOCX file from given markdown filename
func (bk *BookData) DOCX(mdfn string) error {
	fmt.Println("\n####################################\nGenerating DOCX...\n")
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".docx"
	pandoc -f {mdopts} --lua-filter {bk.pdi("glossary-filter.lua")} -F pandoc-crossref --citeproc --bibliography references.bib -t docx --number-sections --reference-doc {bk.pdi("custom-reference.docx")} -o {trg} {mdfn}
	return nil
}

// Refs processes the references 
func (bk *BookData) Refs() error {
	return errors.Log(refs.BibTexCited("./", "allrefs.bib", "references.bib", logx.UserLevel <= slog.LevelInfo))
}

// Markdown generates the combined markdown file that everything else works on.
func (bk *BookData) Markdown() string {
	os.MkdirAll("author", 0750)
	fn := "author/book.md"
	bk.GetFiles()
	bk.Metadata(fn)
	cat "frontmatter.md" >> {fn}
	for ci, ch := range bk.Chapters {
		chdiv := fmt.Sprintf("\n<div class=\"book_section\" id=\"chapter%02d\">\n", ci)
		echo {chdiv} >> {fn}
		cat {ch} >> {fn}
		echo "\n</div>" >> {fn}
	}
	cat "endmatter.md" >> {fn}
	// todo: appendix
	if cosh.FileExists("glossary.md") {
		echo "\n<div class=\"book_section\" id=\"glossary\">\n" >> {fn}
		cat "glossary.md" >> {fn}
		echo "\n</div>" >> {fn}
	}
	echo "# References" >> {fn}
	echo "\n::: {#refs}" >> {fn}
	echo ":::" >> {fn}
	// echo "<div class=\"book_section\" id=\"refs\">\n" >> {fn}
	// echo "# References" >> {fn}
	// echo "\n</div>" >> {fn}
	return fn
}

func (bk *BookData) GetFiles() {
	bk.Chapters = cosh.SplitLines(`ls chapter-*.md`)
	sort.Strings(bk.Chapters)
	if cosh.FileExists("appendix-a.md") {
		bk.Appendicies = cosh.SplitLines(`ls appendix-*.md`)
		sort.Strings(bk.Appendicies)
	}
}

// Metadata outputs the medadata to book.md file
func (bk *BookData) Metadata(fn string) {
	echo "---" > {fn}
	cat metadata.yaml >> {fn}
	// [cat references.yaml >> {fn}]
	echo "---" >> {fn}
}

func (bk *BookData) pdi(fn string) string {
	return filepath.Join(pdInputs, fn)
}

// savePandocInputs saves the embedded pandoc inputs in author dir
func (bk *BookData) savePandocInputs() {
	os.MkdirAll(pdInputs, 0750)
	fns, _ := fs.Glob(PandocInputs, "pandoc-inputs/*")
	for _, fn := range fns {
		fc, _ := fs.ReadFile(PandocInputs, fn)
		_, fb := path.Split(fn)
		tf := bk.pdi(fb)
		cosh.WriteFile(tf, string(fc))
	}
	`chmod +x {bk.pdi("pandoc-filter.py3")}`
}
