// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package book is the book-specific version of Cogent Author for
// rendering markdown source into various book documents,
// including .pdf via latex, .html, .docx and epub.
//
// These files should be located in the current directory where the command
// is run.  Author generates the output files based on Book.Name there,
// with all of the temporary files used in the generation process in the
// 'author' directory.
package book

import (
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"sort"

	"cogentcore.org/cogent/author"
	coshell "cogentcore.org/core/shell"
	"cogentcore.org/core/shell/cosh"
)

var (
	shell    = coshell.NewShell()
	pdInputs = filepath.Join("author", "pandoc-inputs")
)

// Code generated by "cosh transpile"; DO NOT EDIT.

// Book generates a book based on a set of markdown files, with the
// following required file names (with [] indicating optional files):
//
//   - metadata.yaml: pandoc metadata with various important options
//   - frontmatter.md: with copyright, dedication, foreward, preface, prologue sections.
//   - chapter-*.md chapters, using 01 etc numbering to put in order.
//   - endmatter.md: includes epilogue, acknowledgements, author
//   - [appendix-*.md] appendicies, using a, b, c, etc labeling.
//   - [glossary.md] optional glossary that generates links in text.
//   - references are auto-generated from citations in text.
func Book(c *author.Config) error { //types:add
	name := c.Output
	if name == "" {
		name = "book"
	}
	book := NewBookData(name)
	book.savePandocInputs()
	mdfn := book.Markdown()
	var errs []error
	for _, fmt := range c.Formats {
		switch fmt {
		case author.PDF:
			err := book.PDF(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		case author.HTML:
			err := book.HTML(mdfn)
			if err != nil {
				errs = append(errs, err)
			}
		}
	}
	return errors.Join(errs...)
}

// BookData has all of the info about the book.
type BookData struct {
	// Name is the overall name of the book.
	// Output files will be Name.pdf etc.
	Name string

	// names of the chapters, in sorted order.
	Chapters []string

	// names of the appendicies.
	Appendicies []string
}

func NewBookData(name string) *BookData {
	return &BookData{Name: name}
}

func (bk *BookData) pandocMarkdownOpts() string {
	return "markdown+smart+line_blocks+escaped_line_breaks+fenced_code_blocks+fenced_code_attributes+backtick_code_blocks+yaml_metadata_block"
}

// PDF generates PDF file from given markdown filename
func (bk *BookData) PDF(mdfn string) error {
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".pdf"
	// todo: -B {bk.pdi("cover-page.latex")} -- requires metadata replacement
	shell.Run("pandoc", "-f", mdopts, "--lua-filter", bk.pdi("glossary-filter.lua"), "-F", "pandoc-crossref", "--citeproc", "-t", "latex", "--template", bk.pdi("latex.template"), "-H", bk.pdi("header.latex"), "--number-sections", "--toc", "-o", trg, mdfn)
	return nil
}

// HTML generates HTML file from given markdown filename
func (bk *BookData) HTML(mdfn string) error {
	mdopts := bk.pandocMarkdownOpts()
	trg := bk.Name + ".html"
	shell.Run("pandoc", "-f", mdopts, "--lua-filter", bk.pdi("glossary-filter.lua"), "-F", "pandoc-crossref", "--citeproc", "-t", "html", "--standalone", "--embed-resources", "--number-sections", "--css", bk.pdi("html.css"), "-H", bk.pdi("head_include.html"), "-o", trg, mdfn)
	return nil
}

// Markdown generates the combined markdown file that everything else works on.
func (bk *BookData) Markdown() string {
	os.MkdirAll("author", 0750)
	fn := "author/book.md"
	bk.GetFiles()
	bk.Metadata(fn)
	shell.Run("cat", "frontmatter.md", ">>", fn)
	for ci, ch := range bk.Chapters {
		chdiv := fmt.Sprintf("\n<div class=\"book_section\" id=\"chapter%02d\">\n", ci)
		shell.Run("echo", chdiv, ">>", fn)
		shell.Run("cat", ch, ">>", fn)
		shell.Run("echo", "\n</div>", ">>", fn)
	}
	shell.Run("cat", "endmatter.md", ">>", fn)
	// todo: appendix
	if cosh.FileExists("glossary.md") {
		shell.Run("echo", "\n<div class=\"book_section\" id=\"glossary\">\n", ">>", fn)
		shell.Run("cat", "glossary.md", ">>", fn)
		shell.Run("echo", "\n</div>", ">>", fn)
	}
	shell.Run("echo", "# References", ">>", fn)
	shell.Run("echo", "\n::: {#refs}", ">>", fn)
	shell.Run("echo", ":::", ">>", fn)
	// echo "<div class=\"book_section\" id=\"refs\">\n" >> {fn}
	// echo "# References" >> {fn}
	// echo "\n</div>" >> {fn}
	return fn
}

func (bk *BookData) GetFiles() {
	bk.Chapters = cosh.SplitLines(shell.Output("ls", "chapter-*.md"))
	sort.Strings(bk.Chapters)
	if cosh.FileExists("appendix-a.md") {
		bk.Appendicies = cosh.SplitLines(shell.Output("ls", "appendix-*.md"))
		sort.Strings(bk.Appendicies)
	}
}

// Metadata outputs the medadata to book.md file
func (bk *BookData) Metadata(fn string) {
	shell.Run("echo", "---", ">", fn)
	shell.Run("cat", "metadata.yaml", ">>", fn)
	shell.RunErrOK("cat", "references.yaml", ">>", fn)
}

func (bk *BookData) pdi(fn string) string {
	return filepath.Join(pdInputs, fn)
}

// savePandocInputs saves the embedded pandoc inputs in author dir
func (bk *BookData) savePandocInputs() {
	os.MkdirAll(pdInputs, 0750)
	fns, _ := fs.Glob(PandocInputs, "pandoc-inputs/*")
	for _, fn := range fns {
		fc, _ := fs.ReadFile(PandocInputs, fn)
		_, fb := path.Split(fn)
		tf := bk.pdi(fb)
		cosh.WriteFile(tf, string(fc))
	}
	shell.Run("chmod", "+x", bk.pdi("pandoc-filter.py3"))
}
